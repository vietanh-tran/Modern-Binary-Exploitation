## lab7C

This is our first ```heap``` exploitation challenge!

We have 2 structs here:

```c
struct data {
    char reserved[8];
    char buffer[20];
    void (* print)(char *);
};

struct number {
    unsigned int reserved[6];               // implement later
    void (* print)(unsigned int);
    unsigned int num;
};
```

Notice the comment. Hmmm, what's going on?

Continuing in our source code analysis, we see a bunch of identical functions under different names.

* The functions ```small_str``` and ```big_str``` both receive a character pointer as an argument and prints the string located at that address.
* The functions ```small_num``` and ```big_num``` both receive an integer pointer as an argument and prints the number located at that address.

Glancing over the ```print_menu``` function, we have a clue about what these binary does. There are several options in the menu:

```c
void print_menu()
{
    printf("-- UAF Playground Menu ----------------------\n"
           "1. Make a string\n"
           "2. Make a number\n"
           "3. Delete a string\n"
           "4. Delete a number\n"
           "5. Print a string\n"
           "6. Print a number\n"
           "7. Quit\n"
           "---------------------------------------------\n"
           "Enter Choice: ");
}
```

Since this is a ```heap``` challenge, you bet that every ```string``` or ```number``` creation happens on the ```heap```, every deletion is done by calling ```free``` and printing is done by calling the function member of each struct.

In the ```main``` function there is an array of ```struct data``` and an array of ```struct number```, each with 6 elements. Since apparently insertion is done beginning with index 1, we can only keep in memory 5 strings and 5 numbers at maximum.

The chosen function in the structure is determined by the length of the string or the value of the number.

```c
tempstr->print = strlen(tempstr->buffer) > 10 ? big_str : small_str;

tempnum->print = tempnum->num > 0x31337 ? big_num : small_num;
```

With the analysis out of the way, how do we exploit this? Well, since we have a bunch of functions that call ```printf```, we immediately think of trying to perform a ```info leak``` in order to find the address of ```system```.

We know that function addresses are 4 bytes here. Since an integer is exactly 4 bytes, we will have to somehow set ```number->num``` to have the value of a function address. We will do so by a ```use after free``` vulnerability.

When printing a number, an ```if statement``` is perfomed:

```c
if(index < MAX_NUM && numbers[index])
                numbers[index]->print(numbers[index]->num);
```

Our ```index``` will definitely be smaller than ```MAX_NUM``` and since calling ```free``` only sets a ```chunk``` on the ```heap``` as "free" but doesn't actually modify its data, you bet that we will pass the second condition too.

Now, how do we get ```number->num``` to have a function address as a value? We will overlap it with a ```data``` object on the ```heap```. There are exactly ```28 bytes``` of space between the beginning of an object of ```struct data``` and its ```print function``` and exactly ```28 bytes``` between the beginning of an object of ```struct number``` and its variable ```num```.

We will ```make``` a ```number```, ```free``` it, ```make``` a ```string``` and call a function to ```print num```. And voila! We get the value of either ```small_srt``` or ```big_str```, depending on your input. Now we can calculate the address for ```system```.

Now, we have to do the reverse. We can store in ```data->buf``` the string ```"/bin/sh\x00"```, change ```data->print``` with ```system``` and call the function. We have to allocate a ```string``` then ```free``` it then allocate a ```number``` with the ```number->num``` being the address of ```system```.

Since at this point we have a ```data struct``` on our heap, we will only need to ```free``` it and allocate a ```number``` on top of it and call the ```print``` function. Make sure that when you first allocated this ```data struct```, your ```buf``` contains ```"/bin/sh\x00"```. Now simply call the print function and voila!

```bash
lab7C@warzone:/tmp/transcen/lab07$ python expl7C.py
[+] Starting program '/levels/lab07/lab7C': Done
[*] Switching to interactive mode

-- UAF Playground Menu ----------------------
1. Make a string
2. Make a number
3. Delete a string
4. Delete a number
5. Print a string
6. Print a number
7. Quit
---------------------------------------------
Enter Choice: String index to print: $ whoami
lab7A
$ cat /home/lab7A/.pass
us3_4ft3r_fr33s_4re_s1ck
```
